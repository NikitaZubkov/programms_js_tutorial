/**
    ====== Обработка и создание ошибок ======

    Рассмотрим задачу, когда есть функция, которая принимает в качестве аргумента объект и читает его свойства:

    ```
        function test(obj) {
            const func = obj.func();
        }

        test({});
    ```

    В этом случае в лог выведится ошибка, что функции func не существует.
    Чтобы исправить эту ошибку достаточно сделать проверку на существование функции и на проверку типа данных:

    ```
        function test(obj) {
            if (obj.func && (typeof obj.func === 'function')) {
                const func = obj.func();
            } else {
                console.log('incorrect data:', obj.func);
            }
        }

        test({});
    ```

    Однако не всегда есть возможность просто добавить проверку на входящие данные. 
    Например, если функция может принять некорректную JSON строку и попытаться распарсить её:

    ```
        function test(json) {
            const obj = JSON.parse(json);
        }

        const json = '{a: 12, b: ';
        test(json);
    ```

    В данном случае выводится ошибка о не корректном JSON. Аргументом может быть не корретно сохранённый объект или некоторые типы данных:

    ```
        JSON.parse(undefined);
    ```

    Чтобы отлавливать подобные ошибки и не препятствовать выполнению скрипта, в потенциально опасных местах можно использовать try-catch:

    ```
        function test(json) {
            let obj;

            try {
                obj = JSON.parse(json);
            } catch (err) {
                console.log('test: error', err);
                return; // Если продолжать код нельзя, можно выйти из функции
            }

            // Продолжение кода
        }

        const json = '{a: 12, b: ';
        test(json);
    ```

    В данном случае потенциально опасный код занесён в try и если возникнет ошибка, то её содержание будет в переменной err

    === Генерация исключений и ошибок
*/