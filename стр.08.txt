/**
    ====== Объекты, контекст исполнения this ======

    === Прототипы, прототипное наследование, конструкторы функций

    Представим что есть задача создать множество объектов, которые будут между собой отличаться, при этом иметь повторяющиеся методы.
    Будем сохранять объекты в массиве и обращаться к ним из массива:

    ```
    const 
        arr = [],
        N = 10000;

    for(let i = 0; i < N; i++) {
        const obj = {
            test: function() {
                // Код метода
            }
        };

        // ...

        // push - это метод для добавления в конец массива элемента
        arr.push(obj);
    }

    console.log(arr);
    ```

    В результате получили массив с множеством однотипных объектов, которые в дальнейшем будут модифицироваться.
    Однако такое создание объектов с методами не рационально: если отклонить в сторону оптимизацию кода движком JS, то множество 
    однотипных методов у объектов (каждый из которых уникальный объект, а не ссылка на какой-то исходно созданный) должны влиять на затрачиваемое место 
    в памяти.

    Появляются два вопроса:
    1. Как сделать так, чтобы объём занимаемой памяти на созданные объекты был меньше?
    2. Что именно происходит при создании простого объекта или массива и как им изначально доступен ряд методов и полей?

    Ответ кроется в "прототипном наследовании" - это особенность JS, благодаря которой при создании нового объекта он наследует 
    определённые методы и поля от базового объекта. 
    Если у объекта вызывается метод или свойство, то сначала проверяется, есть ли это свойство или метод у текущего объекта.
    Если нет, то это свойство или метод ищется у прототипа. Если у него нет, то у прототипа прототипа и т.д. пока не доходим до базового объекта.
    И если уже там нет, то выводится undefined/ошибка, в зависимости от того что и как мы вызывается.

    При создании простого объекта он наследуется от Object, массив от Array.
    Прототип для текущего объекта можно посмотреть в поле __proto__, в нём хранится ссылка на прототип:

    ```
        const 
            obj = {},
            arr = [];

        console.log(obj.__proto__, arr.__proto__);
    ```

    Ранее при изучении типов данных были рассмотрены не все способы создания объекта.
    Кроме объектного литерала {} и new Object существует вариант Object.create. В этом случае можно указать объект прототип, 
    на который будет ссылаться создаваемый объект:

    ```
        const 
            objProto = {
                a: 12
            },
            objNew = Object.create(objProto);

        console.log(objNew);
    ```

    Второй аргумент для Object.create необязательный, он содержит объект с полями, которые будут в новом обхекте. 
    Правда эти поля должны быть прописаны с так называемыми "дескрипторами свойств", т.е. недостаточно просто указать поле со значением.
    Подробнее про дескрипторы будет ниже.

    Возвращаясь к исходной задаче, достаточно создать объект с полями и методами, от которого будут наследоваться вновь создаваемые объекты:

    ```
    const 
        objBase = {
            test: function() {
                // Код метода
            }
        },
        arr = [],
        N = 10000;

    for(let i = 0; i < N; i++) {
        const obj = Object.create(objBase);

        // ...

        arr.push(obj);
    }

    console.log(arr);
    ```

    Также благодаря Object.create можно создать абсолютно пустой объект, т.к. объект, который не содержит в себе даже свойства __proto__.
    Для этого в качестве прототипа нужно передать null:

    ```
        const obj = Object.create(null);
        console.log(obj);
    ```

    Особенность Object.create является то, что для работы этой фичи в старых браузерах требуется полифилл - кусок js кода, который описывает
    функционал той или иной фичи.

    Подробнее про "объекты, Object.create и прототипное наследование
        https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create
        https://www.youtube.com/watch?v=0vs6WkNyzec&t=5s
        https://habr.com/ru/company/ruvds/blog/420615/
        https://habr.com/ru/post/241587/
        https://habr.com/ru/post/240813/
        https://www.sitepoint.com/oriented-programming-1-4/
        "

    - Частный случай сложения массивов

    https://thedevs.network/blog/type-coercion-in-javascript-and-why-everyone-gets-it-wrong

    - Изменчивать, клонирование объектов

    Более подробно про изменчивость "объектов https://2ality.com/2019/10/shared-mutable-state.html"

    === Контекст
    Рассмотрим задачу когда нам нужно сохранять и изменять данные внутри объекта.
    Для этого можно у объекта создать методы, которые будут изменять те или иные поля:

    ```
        const obj = {
            a: null,
            b: null,
            changeA: function(variable) {
                obj.a = variable;
            },
            changeB: function(variable) {
                obj.b = variable;
            }
        };

        obj.changeA(12);
        obj.changeB(12);

        console.log(obj);
    ```

    Однако обращаться к имени объекта не лучший способ чтобы изменить значение поля.
    Для этого можно использовать контекст функции this.

    Контекст this - это объект, описывающий состояние функции в момент вызова this. Под состоянием имеется ввиду доступные поля, значения, сохранённые в функции.
    Значение контекста зависит от того, где был вызван this. Есть три варианта вызова контекста: 
    - вызов в глобальной области видимости
    - вызов внутри метода объекта
    - вызов внутри функции eval

    Последний пункт не будет рассматриваться, т.к. он практически не встречается в коде.
    Сама функция eval - это изначально доступная функция, которая выполняет код, переданный ей в виде строки:

    ```
        eval('console.log(1);');
    ```

    Более подробно про саму функцию "eval https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/eval"

    === Вызов this внутри метода объекта
    Если вызвать this внутри метода объекта, то в this будут доступны поля и другие
    методы объекта:

    ```
        const obj = {
            a: null,
            b: null,
            changeA: function(variable) {
                obj.a = variable;
            },
            changeB: function(variable) {
                obj.b = variable;
            },
            info: function() {
                console.log(this);
            }
        };

        console.log(obj.info());
    ```

    В этом случае мы можем избавиться от обращения к obj для задания полей:

    ```
        const obj = {
            a: null,
            b: null,
            changeA: function(variable) {
                this.a = variable;
            },
            changeB: function(variable) {
                this.b = variable;
            }
        };

        obj.changeA(12);
        obj.changeB(12);

        console.log(obj);
    ```
    
    === Вызов глобального контекста
    Если вызвать this в функции, которая находится в глобальной области видимости, то в this будет сохранён window:

    ```
        function test() {
            console.log(this);
            console.log(this === window);
        }

        test();
    ```

    В данном случае будет true именно потому что в this сохранена ссылка на глобальный объект.

    Ссылки по this:
    https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this
    https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0
    https://habr.com/ru/post/464163/
    https://medium.com/better-programming/understanding-the-this-keyword-in-javascript-cb76d4c7c5e8
    https://medium.com/javascript-scene/what-is-this-the-inner-workings-of-javascript-objects-d397bfa0708a
    https://getinstance.info/articles/javascript/execution-context/
    https://stackoverflow.com/questions/9218292/what-is-the-difference-between-this-self-window-and-window-self
    https://ponyfoo.com/articles/where-does-this-keyword-come-from

    === Геттеры, сеттеры

    В предыдущих примерах значения полей объекта изменялись при вызове методов changeA, changeB.
    Есть другой способ модифицировать поля - использовать get/set. Это по сути обычные функции, которые видны в коде как обычные поля:

    ```
        const obj = {
            _a: null,
            get a() {
                return this._a;
            },

            set a(variable) {
                this._a = variable + '12';
            }
        };

        obj.a = 12;

        console.log(obj);
    ```

    Более подробно про "get/set 
    https://learn.javascript.ru/property-accessors
    https://dev.to/ogwurujohnson/getters-and-setters-used-in-javascript-objectshow-4jef"

    === Дескрипторы свойств
    
    Ранее были рассмотрены get/set у объекта. Они являются частью объектов и входят в группу так называемых "Дескрипторы свойств".
    Дескрипторы свойств можно описать как свойства свойств, т.е. они определяют поведение и взаимодействие с каждым свойством.
    Сами по себе они являются объектами.

    В JS есть два типа дескрипторов свойств:
    - Дескриптор данных: они определяют значение, возможность чтения и записи свойств
    - Дескриптор доступа: выше упомянутые get/set

    Важно: одно свойство не может быть описано сразу двумя дескрипторами: либо дескриптор данных, либо доступа.
    Задаются эти дескрипторы через метод defineProperty.

    Пример для дескриптора доступа:

    ```
        const 
            obj = {
                a: 12,
                b: 13
            },
            descriptor = {
                get: function() { return cValue; },
                set: function(newValue) { cValue = newValue + 13; },
                enumerable: true,
                configurable: true
            }

        Object.defineProperty(obj, 'b', {
            get: function() { return bValue; },
            set: function(newValue) { bValue = newValue; },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(obj, 'c', descriptor);

        obj.b = 13;
        obj.c = 13;

        console.log(obj);
        console.log(obj.b);
        console.log(obj.c);
    ```

    Здесь
        - enumerable отвечает за то, будет ли свойство перечисляемым (т.е. будет ли оно выводиться при for...in), по умолчанию false
        - configurable отвечает за то, можно ли свойство удалить через специальный оператор delete (подробно про него ниже),
        по умолчанию значение false

    Т.к. дескрипторы это объекты, то их можно хранить в переменной и использовать в defineProperty в качестве аргумента. 

    В случае задания свойства b через defineProperty оно также будет доступно при прямом вызове, однако при простом выводе объекта оно не будет
    отображаться в консоли.

    Если поле изначально существовало, оно модифицируется согласно прописанным дескрипторам свойств.

    Пример для дескрипторы данных:

    ```
        const obj = {};

        Object.defineProperty(obj, 'a', {
            enumerable: false,
            configurable: false,
            writable: false,
            value: 'static'
        });

        obj.a = 13;

        console.log(obj);
        console.log(obj.a);
    ```
    Здесь
        - value: непосредственное значение поля, по умолчанию undefined
        - writable: статус который показывает, можно ли изменять поле, по умолчанию false 

    Более подробно про дескрипторы "свойств 
    https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
    https://learn.javascript.ru/property-descriptors
    https://habr.com/ru/company/ruvds/blog/438794/".

    === Оператор delete
    Для удаления свойств в объекте используется специальный оператор delete:

    ```
        const obj = {
            a: 12
        };

        delete obj.a;

        console.log(obj);
    ```

    При работе с ним есть несколько важных моментов. 
    Во-первых, он не может удалить глобальные переменные:

    ```
        var a = 12;

        delete window.a;

        console.log(window.a);
    ```

    Впрочем как и другие переменные, объявленные через let, const, т.к. delete удаляет только конфигурируемые свойства, 
    т.е. те, что были прописали например через объектный литерал {}:

    ```
        const obj = {
            d: 12
        };

        Object.defineProperty(obj, 'd', { configurable: false });

        delete obj.d

        console.log(obj);   // свойство не удалилось из-за свойства configurable:false
    ```

    Во-вторых, delete не удаляет примитивные значения. Он работает только с объектами:

    ```
        const a = 12;

        delete a;

        console.log(a)
    ```

    В-третьих, использование delete с массивами не лучшая идея, т.к. свойство length не будет уменьшено, а в логах на месте элемента будет empty:
    
    ```
        const a = [1,2,3];

        delete a[0];

        console.log(a); 
    ```

    Для удаления элемента в массиве используются определённые методы, о которых будет в главе Массивы.

    В четвёртых, значение, возвращаемое delete:
    - если поле удалено успешно или не найдено, то вернётся true
    - если поле нельзя удалить, то вернётся false

    ```
        const 
            a = 12, 
            b = {
                c: 13,
                d: 14
            };

        Object.defineProperty(b, 'd', { configurable: false });

        console.log(delete a);      // false
        console.log(delete b.c);    // true
        console.log(delete b.d);    // false
    ```

    Более подробно про delete можно прочитать "здесь
    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete
    https://medium.com/better-programming/javascript-delete-keyword-in-detail-4bdcf32dcdd8
    https://blog.bitsrc.io/understanding-the-delete-operator-in-javascript-3791ba6f3a08
    https://blog.caplin.com/2012/01/31/javascript-is-hard-part-3-you-cant-delete-with-delete/
    "
*/