/**
    ====== Функции ======
    
    Представим задачу: мы написали код, решающий определённую задачу. 
    Однако в скрипте повторяются значительные куски кода, и которые нужно удалить и заменить вызовом одной конструкции, 
    хранящей наш повторяющийся код.
    Такой конструкцией является функция:

    ```
    // Объявление функции
    function NameFunction (arg1, arg2, ...) {
        // тело функции

        return result;
    }

    // Вызов функции
    NameFunction(argument1, argument2, ...);
    ```

    где: 
    - function: зарезервированное слово, указывающее на то, что далее будет код функции
    - NameFunction: имя функции, которое можно использовать для её вызова
    - argument1, argument2, ... - необязательные аргументы которые передаются в функцию и которые можно использовать в рамках этой функции
    важно: argument1 === arg1, а argument2 === arg2, т.е. программист сам определяет, как назвать аргументы, которые будут использоваться в NameFunction
    - return: необязательная конструкция, возвращающая какое-либо значение. return не обязателен, т.к. если не прописать его, то функция  
    вернёт undefined. В качестве result может быть любое значение, другая функция, результат арифметических или логических операций и т.д. 
    Тело функции в отличие от if и for всегда нужно оборачивать {}

    Важно понимать, что объявление функции не означает её вызов. После объявления она будет доступна для последующего вызова.

    Пример использования функции:

    ```
    function logVariable(variable) {
        /**
         * Выводим в лог строку со значением variable
         * console.log - это тоже вызов функции, хранимой под ключом log в объекте console
         * функция, вызываемая по ключу log, может принимать и выводить сколько угодно аргументов, если их перечислить через запятую
         */
        console.log("переданная переменная variable", variable);
    }
    
    function returnValue(variable) {
        return variable + 42;
    }

    logVariable(42);

    var b = returnValue(12);
    console.log(b);
    ```

    Вернёмся к объектам.
    Как ранее было сказано, объект - это тип данных в js, который может хранить в себе данные по задаваемым программистом ключам.
    Т.е. в объекте мы можем указать следующее: 
    
    ```
        /**
         * Объявляем переменную obj, сохраняем в ней объект
         * в объекте прописываем поле с ключом log и значением logVariable
         * соответствующим названию функции logVariable
         */
        var obj = {
            log: logVariable
        };
        
        function logVariable(variable) {
            console.log("переданная переменная variable", variable);
        }

        // вызываем функцию logVariable, передаём в неё один числовой аргумент со значением 444
        obj.log(444)
    ```

    Заметим, что если объявить функцию через function и не сохранять её в отдельную переменную, то мы можем получить доступ к функции вне зависимости от того
    в каком месте скрипта она объявлена.

    Т.е.:

    ```
    // Будет вызвана функция, ошибки не будет
    test1();

    /**
     * Вызова не будет, скрипт не будет выполнен до конца, программа остановится на текущем моменте, т.к. 
     * при объявлении функции test2 важно, в каком месте программы объявлена и вызвана test2
     * появится ошибка о том test2 - это не функция, а undefined
     */
    test2();

    function test1 () {
        console.log(1);
    }

    var test2 = function () {
        console.log(2);
    }

    console.log(3);
    ```

    Данная ошибка связана с темой областью видимости переменной.

    === Область видимости

    Допустим у нас есть задача в решении квадратного уравнения ax^2 + bx + c = 0: есть функция, 
    в неё передаётся три аргумента и нужно найти решение. Аргументы могут быть положительными или отрицательными.

    В функции будут следующие операции::
    1. нужно вычислить дискриминант D = b^2 - 4*a*c
    2. Смотрим на знак и на значение D:
        - положительный : значит есть два корня, их значения вычисляется по формуле (-b +- D^0.5)/(2*a)
        - значение равно 0: (-b)/(2*a)
        - отрицательный : значит корней нет
    3. Вычисляем корни если можно
    4. Возвращаем результат ()

    Напишем один из вариантов такой функции:

    ```
    // Наша функция с переданными тремя аргументами
    function quadraticEquation(a, b, c) {
        /**
         * Вычислим дискриминант D, а также сохраним текст для третьего результата (корней нет)
         * в переменную result, чтобы не писать лишний else в условии ниже
         * Объявим также промежуточные переменные x1, x2, если D > 0
         */
        var D = (b * b) - 4 * a * c,
            result = "Нет корней",
            x1,
            x2;

        if (D > 0) {
            x1 = (-b + Math.sqrt(D)) / (2*a);
            x2 = (-b - Math.sqrt(D)) / (2*a);

            result = {
                x1: x1,
                x2: x2
            }
        } else if (D === 0) {
            x1 = (-b) / (2*a);

            result = {
                x: x1
            }
        }

        return result;
    }

    var variableQE = quadraticEquation(2,-1, 4);

    console.log(variableQE);
    ```

    Некоторые замечания:
    1. Math - это объект, доступный в любом месте скрипта, в котором хранятся математические функции.
    2. sqrt - это ключ для доступа к функции вычисления квадратного корня
    3. return может возвращать только одно значение. Поэтому для передачи более одного значения можно использовать массив или объект
    4. необязательно создавать какие-то промежуточные переменные для хранения результата. Можно было бы напрямую вычислить значения корней в самом result:

    ```
    result = {
        x1: (-b + Math.sqrt(D)) / (2*a),
        x2: (-b - Math.sqrt(D)) / (2*a)
    }
    ```

    Однако в этом случае код становится менее читаемым. Однако в некоторых случая это может быть допустимо.
    В зависимости от Вашего стиля написания кода или стиля в команде, в которой Вы работаете.

    Возвращаясь к самой задаче: 
    после того как была написана функция мы дальше продолжили работу. 
    Однако появляется вопрос: те переменные, которые мы объявили в quadraticEquation: будут ли они доступные в других функциях? 

    ```
    function quadraticEquation(a, b, c) {
        var D = (b * b) - 4 * a * c,
            result = "Нет корней",
            x1,
            x2;

        ...
    }

    var variableQE = quadraticEquation(2,-1, 4);

    console.log(variableQE);
    console.log(D);
    console.log(result);
    ```

    Появится ошибка о том, что переменной D не существует.
    Это произошло потому, что в JS существует такое понятие как лексическая область видимости - Lexical Scoping 
    (другие варианты перевода «лексическая область действия» или «лексическая область определения»).
    Смысл лексической области видимости в том, что переменная, определенная в одной части программы, может быть недоступна в другой части программы.

    В свою очередь лексическая область делится на:
    - глобальную область видимости
    - локальную область видимости

    ```
    /**
     * Глобальная область видимости, 
     * все объявленные в ней переменные будут доступны в любом месте кода
     */
    var a = 10,
        b = 12;

    function test() {
        /**
        * Локальная область видимости, 
        * в данном случае у нас область видимости функции
        * и все объявленные здесь переменные будут доступны только в рамках {}
        * в глобальной области видимости переменные, объявленные здесь, не будут видны 
        */

        // Изменение значения глобальной переменной b
        b = 15;

        /**
         * Объявление новой переменной a, 
         * значение которой будет действительно только в области видимости функции test
         */
        var a = 12;

        console.log("Вывод №1", a, b);
    }

    console.log("Вывод №2", a, b);

    test();

    console.log("Вывод №3", a, b);
    ```

    Сначала у нас вывелось "Вывод №2", т.к. объявление переменной не означает её вызова.
    Далее выводится Вывод №1, т.к. мы вызвали функцию test. значение a === 12, т.к. мы вызываем значение новой переменной a, значение переменной b
    же мы изменили до Вывод №1.

    Далее выводится Вывод №3, здесь у нас значение b уже изменилось, т.к. оно было изменено при вызове функции test.

    Основная задача область видимости в первую очередь недопустить переписывание (а следовательно и возникновение ошибок) 
    переменных с одними и теми же именами. Благодаря области видимости можно создавать независимые друг от друга куски кода.

    Это можно реализовать на базе например объектов: 

    ```
    var obj = {
        a: 0,
        b: 0,

        init: function () {
            obj.test1();
            obj.test2();

            console.log("call main function init", obj.a, obj.b);
        },

        test1: function() {
            obj.a = 12;
            console.log("call function test1");
        }, 

        test2: function() {
            obj.b = 15;
            console.log("call function test2");
        }
    }

    obj.init();
    ```

    Т.е. все нужные нам переменные хранятся в obj, а сам obj хранится в глобальной области видимости.

    Другая задача области видимости: недопустить т.н. утечек памяти, когда часть занимаемой памяти не освобождается в ходе работы программы.
    Ответственность за удаление неиспользуемой памяти в js лежит на сборщике мусора - части движка js.
    Одной из причин утечки памяти - использование глобальных переменных, которые сборщиком не могут быть удалены.

    Более подробно про "утечки памяти https://habr.com/ru/post/309318/ https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_Management" 
    и про "сборщик мусора https://learn.javascript.ru/garbage-collection https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_Management#%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0"

    Для доступа к глобальным переменным используется глобальный объект. В браузере это window:

    ```
    var a = 12;
    
    function test() {
        var a = 15,
            b = 42;

        // Получаем значение локальной переменной a
        console.log(a);

        // Получаем значение глобальной переменной a
        console.log(window.a);

        // Напрямую сохраняем в window новую переменную
        window.b = b;
    }

    test();

    // Получаем переменную b, добавленную в объект window
    console.log(b);
    ```

    В window хранятся: 
    - все переменные, объявленные через var в глобальной области видимости или напрямую прописанные в window
    - все изначально доступные переменные и объекты, например Math:

    ```
    console.log(Math);
    console.log(window.Math);

    // Результат будет true, т.к. это вывод одного и того же объекта
    console.log(Math === window.Math);
    ```

    === let, const
    Мы разобрались с областью видимости, но ранее упоминалось, что var - это не единственный способ объявить переменную.
    Также для объявления переменной существуют два ключевых слова:
    - let
    - const: тот же самый let, отличие только в том, что переменная, объявленная через const может инициализироваться только один раз:
    
    ```
    const a = 12;
    a = 13; // появится ошибка что нельзя менять значение у константы

    const b; // ошибка, требуется инициализация переменной
    ```

    Однако при работе с объектом у const есть особенность: мы также не можем заново инициализировать переменную. Однако можно добавлять или 
    удалять поля у объектов:

    ```
        const obj = {};

        obj.a = 12;

        console.log(obj);
    ```

    let и const появились в JS не сразу: впервые они были добавлены в js после появления ES6: там было описано много фич, в том числе и let с const.
    Добавлены они были для повышения безопасности при кода.

    Отличие let/const от var в области видимости объявленной переменной, особенностях поднятия переменной и количеству раз объявления переменной.

    === Объявление переменной с одинаковым именем через let, var, const

    При работе с var не будет ошибкой если Вы повторно объявите переменную с одним и тем же именем:

    ```
    var a = 12;
    var a = 13;

    console.log(a);
    ```

    В этом случае значение просто перепишется.
    В случае с let и const такое не получится сделать:

    ```
    let a = 12;
    let a = 13;

    console.log(a);
    ```

    Появится ошибка о том, что переменная a уже была объявлена.
    Аналогично с const.

    === Область видимости переменных 
    Второе отличие var от let - область видимости.
    Область видимости у let и const "блочная", т.е. переменная, объявленная через let/const видна только в рамках {}:

    ```
    var a = 12,
        b = 12;

    if (true) {
        var a = 15;
        let b = 15;

        console.log("Переменные a и b в области видимости if", a, b);
    }

    console.log("Переменные a и b в глобальной области видимости", a, b);
    ```

    Т.е. после захода в условие, мы переписали значение переменной a, но не переменной b: её значение в глобальной области видимости
    не изменилось. В условии мы объявили новую переменную b, которая перестала быть видна того, как мы вышли из тела условия.

    Аналогично с циклом:

    ```
    for (var i = 0; i < 10; i++) {
        var k = i;
    }

    for (let j = 0; j < 10; j++) {
        let l = j
    }

    console.log("Переменные, объявленные через var", i, k);
    console.log"Переменные, объявленные через let", (j, l);
    ```

    Появится первый лог, в нём i === 10 (т.к. цикл дошёл до i === 10 и остановился) и 
    k === 9 (т.к. после i === 10 мы не зашли снова в тело цикла, а вышли из него).

    А вот второго лога нет, вместо него ошибка, что переменной j не существует, т.к. её область видимости находится в рамках {}.
    Важно что ошибка появится только на j, т.к. как только появляется ошибка работа скрипта заканчивается и до l интерпретатор не дойдёт.

    Следствием области видимости у let/const является взаимодействие с глоабльным объектом window.
    При объявлении переменной var в глобальной области видимости, эта переменная становится добавляется в window:

    ```
    var a = 12;

    console.log(window.a);
    ```

    При таком же объявлении через let переменная не будет добавлена в window:

    ```
    let b = 12;

    console.log(window.b); // Будет выведено undefined
    ```

    Если в двух словах, то в JS существует существует такое понятие как "запись среды" (Environment Records), отвечающей за то, как 
    хранятся те или иные конструкции (переменные, функции и пр.) в JS.
    И вот записи среды делятся на:
    - декларативные записи среды, связанные с определённой область видимости, в которой объявлены let,const и пр. конструкции
    - объектные записи среды, которые используют объект JS в качестве структуры данных

    Поэтому когда мы говорим про глобальную область видимости, мы также упоминаем глобальную запись среды, которая включает в себя объектную запись среды
    (которая по умолчанию использует глобальный объект window) и декларативную запись среды, в которую сохраняются переменные let/const.

    Более подробно про эту особенность "здесь 
    https://codeburst.io/difference-between-let-and-var-in-javascript-537410b2d707 
    https://2ality.com/2019/07/global-scope.html
    https://stackoverflow.com/questions/39414692/a-javascript-let-global-variable-is-not-a-property-of-window-unlike-a-global
    https://stackoverflow.com/questions/28776079/do-let-statements-create-properties-on-the-global-object
    https://fooobar.com/questions/504047/whats-the-difference-between-lexicalenvironment-and-variableenvironment-in-spec
    "

    === Поднятие переменной и функции
    Второе отличие var от let в поднятии переменной.
    Если попытаться получить доступ к переменной, объявленной через var, до её объявления, то получим undefined:

    ```
    console.log(a);

    var a = 10;
    ```

    Это происходит из-за того, что js "поднимает" переменную в "верх области видимости", 
    т.е. мы получим информацию о том, что эта переменная существует. При этом по умолчанию ей присваивается значение undefined.
    Благодаря этому возможно такое поведение:

    ```
    a = 13;

    var a;

    console.log(a);
    ```

    Аналогично по подъёму с var ведут себя и функции:

    ```
    // Первая функция доступна для вызова
    console.log(test);
    function test() {}

    // Вторая функция также доступна для вызова
    function test1() {}
    console.log(test1);

    // В этом случае функция не доступна
    console.log(test2);
    var test2 = function() {};

    // Третья функция уже доступна для вызова
    console.log(test2);

    ```

    Функции тоже поднимаются на верх своей области видимости и сами они будут доступны для вызова. Если же функцию сохранить в переменную,
    то тут появляются особенности поднятия при var/let/const.

    Если же попытаться вызвать переменную, объявленную через let, до её объявления, то будет ошибка:

    ```
    console.log(a);

    let a = 15;
    ```  
    Это происходит из-за так называемой "мёртвой петли" (или временная мёртвая зона) - это следствие особенности работы движка с переменными.
    Все переменные, объявленные через var, let, const видны и все они поднимаются в области видимости. 
    Отличие от var в том, что var первоначально инициализируется undefined и интерпретатор знает, в каком месте находится переменная.
    let и const будут инициализированы только тогда, когда интерпретатор дойдёт до их непосредственной инициализации в коде и когда их положение
    в коде будет известно. А до тех пор к ним нельзя обратиться, т.к. неизвестно их значение и положение в коде.

    Более подробно про особенности подъёма переменной, объявленной через let "можно прочитать здесь https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda".

    Ссылки на статьи по области видимости, var/let/const:
    https://dmitripavlutin.com/javascript-variables-and-temporal-dead-zone/
    https://css-live.ru/articles/es6-let-const-i-vremennaya-myortvaya-zona-vmz-iznutri.html
    https://habr.com/ru/post/462971/
    https://fullstackgeek.blogspot.com/2019/01/variables-scope-in-javascript.html
    https://tylermcginnis.com/var-let-const/

    === var, let, const и условия/циклы

    В конце данной темы упомянем работу с переменными в условиях и циклах если мы не заходим в их тела.
    Допустим в глобальной области видимости мы напишем:

    ```
    if (false) {
        console.log("Зашли в тело условия");

        var a = 12;
        let b = 12;
    } else {
        console.log("Попали в else");
    }

    console.log(a);
    console.log(b);
    //console.log(c);
    ```

    Мы не зашли в тело условия, где объявляются переменные a и b. 
    Однако у нас вывелось undefined и ошибка, что переменной b не существует.
    Эта же ошибка произойдёт если вывести переменную, которая вообще не объявлялась.

    Как таковой области видимости у условия нет. Все переменные, объявленные в if, будут подниматься в области видимости, окружающей if 
    (даже если мы не заходили в соответствующие {}, где происходило объявление переменных).

    ```
    for(let i = 10; i < 10; i++) {
        var j = 1;
        let k = 2;
    }

    console.log(j);
    console.log(k);
    ```

    Более подробно про "область видимости и условия https://stackoverflow.com/questions/6964895/javascript-variable-scope-in-the-if-statement"
*/